// https://web.qianguyihao.com/04-JavaScript%E5%9F%BA%E7%A1%80/10-%E8%BF%90%E7%AE%97%E7%AC%A6.html#%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6
// 假设用户输入 345，怎么分别得到 3、4、5 这三个数呢？
const num = 345;
console.log(`百位:${parseInt(num / 100)}`);
console.log(`十位:${parseInt(num % 100 / 10)}`);
console.log(`个位:${num % 10}`);

// 浮点数运算的精度问题
console.log(0.1 + 0.2);
console.log((0.1 + 0.2).toFixed(2));
/**
 * 0.30000000000000004
 * 浮点数失真的本质是因为:计算机只能存储和运算二进制的数字,所以首先转换进制，小数转换为二进制存在精度失真的问题
 * 例如:0.1-(乘2取整正序排列)->0.2 0.4 0.8 1.6 | 1.2 0.4 0.8 ... 取整后小数部分为:0001 100...
 *     0.2-->0.4 0.8 1.6 1.2 0.4 0.8 1.6 1.2 ... 取整后小数部分为:0011 0011 ...
 * 最后由于二进制数循环 导致底层精度失真 所有的语言都有的一个底层的问题
 * js的解决方案：简单方案为调用toFixed(保留几位数字) 要求精确的时候可以引入第三方库decimal.js Math.js...
 */

// ==这个符号并不严谨，会做隐式转换，将不同的数据类型，转为相同类型进行比较（大部分情况下，都是转换为数字）
// undefined 衍生自 null，所以这两个值做相等判断时，会返回 true
console.log(undefined == null);

// ===全等符号的强调
// 全等在比较时，不会做类型转换。如果要保证绝对等于（完全等于），我们就要用三个等号===。例如：
console.log('6' === 6); //false
console.log(6 === 6); //true

// Unicode 编码
console.log('\u2600'); // 这里的 2600 采用的是16进制
console.log('\u2602'); // 这里的 2602 采用的是16进制。
